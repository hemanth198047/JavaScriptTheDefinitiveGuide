A function is a block of code that is defined once but may be executed or invoked any number of times. 
Javascrpt functions are parameterized -- a function definition may include a list of identifiers, known as parameters that acts as local variables for the body of the function.
Function invocations provides values or arguments for the function's parameters.
Functions often use the values of their arguments to compute the return value that becomes the value of the function invocation expressions. 
In addition to arguments, each invocation has another value -- Invocation Context -- That is the value of this keyword.

If a function is assigned to a property of an object, then that function is called method of that object. 
If a function is invoked on or through an object, that object becomes the invocation context or this of that function
Functions designed to initialize a newly created object are called Constructors.

In Javascript, functions are objects and they can be manipulated by programs and they are treated as simple variables. Since they are treated as simple variables, they can be passed
as arguments to another functions. Since Functions are objects, you can set properties on them and then invoke methods on them as well.

functions can be nested within another functions and they have access to variables that are in scope where the functions are defined. this means, javascript functions are closures.

Defining Functions
==================
Functions are defined using the function keyword, which can be used in function definition expression or in function declaration statement. in both the cases, function definition
starts with function keyword followed by these components
1. an identifier that names the function. the name part is required in function declaration statement where the function object is created and assigned to the variable with the name same
   as defined as function name. For function definition expression, name is optional and if present, will be used only inside the function body
2. A pair of paranthesis around zero or more identifiers called parameters. These parameters acts as local variables inside the body of the function
3. A pair of curly braces with zero or more java script statements inside it. These statements are body of the function and are executed whenever the function is invoked.

a function defined as an expression can be used only in the context of other larger expressions. examples are in app.js.

Note that function names are optional while defining a function definition expression. a function declaration statement actually defines a function object and then assign that object to a
variable where as in function definition expression, it is not assigned to any variable but is used directly. 

Normally a function definition expression does not include any name. But in case if there is one name given to function definition expression, then, the local function scope for that function
will include the binding of the function name to that function object. In effect, the function name becomes the local variable within that function body. 

Any legal javascript identifier can be a function name. 

One important point to note is that all the function declaration statements are hoisted to the top of the enclosing script or the enclosing function so that functions declared in this way
can be invoked even before they are defined. But this is not true for function definition expressions. However, the variable declarations alone are hoisted but not their assignments. Hence,
if a function declared, we can't just invoke it until it is assigned with some value.

A function return statement causes the function to stop executing and return the value of its expression to the caller. if the return statement does not have an associated expression, it
returns undefined value. 

Functions with no return values are sometimes called as procedures.

Nested Functions
================
In javascript, functions can be nested within other functions.
example:
  function hypotenuse(a, b) {
    function square(x) {
        return x*x;
    }
    return Math.sqrt(square(a0 + square(b)));
  }

  The interesting thing about nested function is their variable scoping rules. they can access the variables and parameters of the function they are nested within.
  in the code above, the function square can access the parameters a and b.

  In Javascript, function declaration statements are not true statements and ECMAScript specification allows them only as top level statements. this means function declaration statements
  can appear in global code, within other functions but they can't appear inside of loops, conditionals, or try/catch/finally or with statements. This restriction only applies when functions
  are defined as statements only. Function definition expressions can appear anywhere inside the javascript.

Invoking Functions
==================
the javascript code that forms a function body will not be executed when it is defined but will be executed when the function is invoked. javascript functions can be invoked in 4 ways
1. As functions
2. As Methods
3. As Constructors
4. As indirectly through call and apply methods

Function Invocation
===================
Functions are invoked as functions or methods with an invocation expression.
An invocation expression consists of a function expression which is evaluated to a function object, followed by a open paranthesis and zero or more expressions evalauted to parameters and
followed by a closing paranthesis. if the function expression is a property access expression, which means, if the function is a property value of an object or an element in an array
then it is called method invocation expression. 

In an invocation, each argument expression is evaluated and the resulting value becomes the arguments to the function. these values are assigned to the parameter names defined in function.
inside function body, a reference to parameter names evaluates to the corresponding argument value.

for regular functions, the return value becomes value of the function invocation expression. if the function reaches to end after executing all statements inside the function, then, return
value becomes undefined.

for function invocation in ECMAScript 3 and non-strict ECMAScript 5, the invocation context (the this) is the global object. However, in strict mode it is undefined.

Functions written to be invoked as functions do not typically use the this keyword at all. this fact can be used to identify whether we are using strict mode or not. refer app.js for reference.

Method Invocation
=================
A method is nothing but a function that is stored as a value for a property in an object. If you have a function f and an object o, you can define a method named m of o with the following line
o.m = f;

Having defined a method m() of the object o, invoke it like this
o.m();

if the method expects any arguments, you can pass the arguments to o.m() as well.

the code above is an invocation expression which has a function expression and 2 arguments for it. here the function expression itself is a property access expression and this means that
the function is invoked as a method rather than a regular function.

method invocation expressions acts exactly same as regular expressions. Only difference is that, in method invocation, the object on which the method is invoked becomes the invocation context
of the function where that object is referred to with "this" inside the method invocation.

example:
   var calculator = {
    operand1:1,
    operand2:1,
    add: function() {
        this.result = this.operand1 + this.operand2;
    }
   };

   calculator.add();
   calculator.result;

   most method invocations use dot notation to access the property, but property access expressions that use square brackets also cause method invocation.
   ex: o.m(x, y) can also be written as o["m"](x,y)

   method invocations may also involve more complex property access expressions.
   ex: customer.surname.toUppercase(); f().m();

   methods and this keyword are central to object oriented programming. Any function that is used as a method is implicitly passed an argument -- the object through which it is invoked.
   typically, a method performs some sort of operation on that object, and the method invocation expression syntax is an elegant way to express the fact that a function is operating on
   an object. compare the following 2 lines
   
   rect.setSize(width, height);
   setRectSize(rect, width, height);

   from the above two lines, we can see that both are performing the same operation but the method call on rect object is more clear than the latter one.

   When a method returns an object, you can use that return value to invoke some other methods on the returned object. this is called method chaining and this type 
   of method chaining is observed more in JQuery.

Please remember that method chaining is completely different from constructor chaining.

unlike variables, this keyword does not have any scope and nested functions do not inherit this value of their caller. If a nested function is invoked on a method, then that object
becomes this value inside that function. It is a common mistake to assume that when a nested function is invoked as a function, then, its this value is either a global object or
undefined but not the this object of the outer function.

When a nested function is invoked as a function, then, we can't use its this property to retrieve the invocation context of the outer function. so, in this case, if you want the invocation
context of the outer function, you need to specifically store that in a separate variable and using that variable you can get the invocation context of the outer function.

example:

var o = {
    m: function() {
        var self = this;
        console.log(this === o);
        f();
    }

    function f() {
        console.log(this === o);
        console.log(self === o);
    }
};
o.m();

refer app.js for execution of the above code.

Constructor Invocation
======================
If a function or method invocation is preceeded by new keyword, then it is a constructor invocation. These constructor function invocations differ from the regular function invocations
in the terms of handling arguments, invocation context and return values.

In constructor functions, if there are arguments to be passed, then, they are handled as regular functions itself. But if there are no arguments, then, there is no need specify the 
parantheis itself. 
example: var v = new Object() and var v = new Object  both are same only.

a constructor invocation creates a new empty object that inherits from prototype property of the constructor. Constructor functions are intended to initialize objects and this new object
is used as the invocation context so the constructor function can refer to it with this keyword. Note that the new object is used as the invocation context even if the constructor function
call looks like method invocation. Example: In case of new o.m(), o is not the invocation context of new object but prototype of the constructor is the invocation context.

Constructor functions do not normally use the return keyword. they typically initialize new object and then return implicitly when they reach the end of the body. in this case new object
is the return value of constructor function expression. in case if constructor function returns any specific value, then that value becomes the value of the invocation expression. If the 
constructor function returns no value or returns a primitive value then that will be ignored and the new object is used as the value of the invocation expression.

Indirect Invocation
===================
Javascript functions are objects and like all other objects, they have methods. Two of these methods are call() and apply(). they are used to invoke a function indirectly. Both of these methods allow you to explicitly specify this object as invocation context. This means, you can invoke any function as a method of any object, even if it is not actually the method of that
object. Both methods also allows you to specify the arguments of the functions that is being invoked. The call() method uses its own argument list as arguments to the function and
apply() method expects an array of values to be used as arguments.

Function arguments and Parameters
=================================
Javascript functions do not specify expected type for their parameters and function invocations do not perform any type checking on their parameters. In fact, javascript do not even
check the number of arguments passed to a function. Following sections describe what happens when fewer arguments are passed to a function than expected and what happens when more
arguments are passed to a function than expected.

Optional Parameters
-------------------
when a function is invoked with fewer parameters than the declared parameters, the additiona parameters are set to undefined. For example refer app.js

Note that if we are using the optional arguments, then, they should go as the last aruments in the function call.

Variable length arguments Lists: The Arguments Object
-----------------------------------------------------
When more number of arguments are passed to a function than the defined parameters, then, there is no way to refer to those extra arguments. Arguments object is the solution for this problem.
Arguments belongs to the local scope of a function. It is an array like object that holds all the arguments passed to the function and those arguments can be accessed using the index
rather than the argument name.

The Arguments is an array like object and hence it contains a length property. based on this property, we can access the arguments that are passed to a function based on their position.
This Arguments object can be used to perform certain sanity checks like whether a function is called with the expected arguments or not.
This is normally not required because default behavior of javascript is that missing arguments are replaced with undefined and extra arguments are ignored.

One important use of Arguments object is that it can be used to write the functions that can operate on any number of arguments. for example of such type of function refer app.js
Functions like this that accepts any number of arguments are called variadic functions or variable arity functions or varargs functions. 

Note that varargs functions need not allow zero arguments. it is perfectly reasonable to use the arguments[] object to write functions that expect some fixed number of named and required
arguments followed by an arbitrary number of unnamed optional arguments.

The Arguments object has some unusual feature. In non-strict mode, when a function has named parameters, the array elements of argument object are aliases for parameters that holds 
the arguments. the numbered element of argument object and the parameter names are like two different names for the same value. changing the value of an argument in one form will affect
the retrieval of the same element using another form. 

this special behavior of arguments is removed in ECMAScript 5. In strict mode Arguments is a reserved word but in nonstrict mode it is merely an identifier. 

The Callee and the Caller properties
-----------------------------------
In addition to it's array elements, Arguments object also defines callee and caller properties as well. In ECMAScript 5, if we try to read/write these properties, TypeError will be raised.
Outsisde of strict mode, Callee refers to the currently running function and Caller refers to the function that called this function. The Caller property provides access to call stack
and callee function is used to call unnamed functions by themselves recursively.

Using Object properties As Arguments
------------------------------------
There will be situations where a function accepts more number of arguments and user might get confuse in remembering the names of those arguments. To solve this problem, we can create
an array with arguments as name/value pairs and then pass that array as argument to the function. This array then will be mapped to Aruments object and Arguments object can then be used
to access the arguments using their names.

Example: refer app.js for Using object properties as arguments

Argument Types
--------------
When a function declares parameters, normally on invoking a function, the arguments are not checked for any type. For that case, it will not even check how many arguments are passed to the
function. But normally, type conversion of arguments will take place accordingly and implicitly. But this is not the case in all scenarios.
There are chances where type conversion will fail say for example first argument of a function is expected as array and if we pass something that cannot be converted to array, then this
function call will fail because implicit type conversion also fails.

So, it is better to do the type checking on ourselves before we proceed further with using those arguments.

Functions as Values
===================
The most important feature of a function is that it can be defined and invoked. The role of a function is only this much in other programming languages but not in javascript.
in javascript, functions can also play a role of a value, which means they can be stored in variables, can be used as arguments to other functions, can be stored as values of properties in
an object or also can be stored as a value in an array.

to understand this further consider below function definition

function square(x) {return x*x;}

This definition creates a new function object and then assign that object to a variable called square. the name of the function is immaterial but is the only name of the variable that
holds the function object. the function then can be assigned to some other variable and still works in the same way.
For Example: var b = square; 
This statement assigns the function object to b as well and now both b and square refers to the same function object.

The functions can also be assigned to properties in an object. If we do this, then they are called as methods. Functions don't even need a name as they are assigned as elements in an array.

Example:  
    var a = [function(x) {return x*x;}, 21];
    a[0](a[1]);

In this example, first element represents a function and the value passed to this function is second element of the array.

Please refer app.js for examples of using functions as data.


Defining your own function properties
=====================================
A function is a specialized object in javascript and it can have its own properties.
Suppose we need a static property that holds data across the invocations a function, then, it is better to define that property as a function property.
By defining function properties, we can avoid cluttering the global namespace.

Example:
// Initialize counter property in a function. since function declarations are hoisted, we can declare a function property before even the function is defined
uniqueInteger.counter = 0;

// Now define the function. This function returns a different integer each time it is invoked.
// It uses a property of itself to remember the next value to be returned.
function uniqueInteger() {
    return uniqueInteger.counter++;
}

As another example, consider the following factorial() function that uses properties of itself(treating itself as an array) to cache previously computed results.
function factorial(n) {
    if (isFinite(n) && n>0 && n=Math.round(n)) { // Finite, positive ints only
        if (!n in factorial) { // If no cached result
            factorial[n] = n * factorial[n-1];
        }
        return factorial[n];
    }
    else {
        return NaN;
    }
}

factorial[1] = 1;

Refer app.js for working example

Functions as Namespaces
=======================
We already know that each and every function has a function scope. variables declared inside a function is visible throughout the function. variables declared outside a function is a global
variable and is visible throughout the javascript program. In order to avoid polluting the global namespaces, we use functions itself as namespaces where variables defined inside a function
is visible through out the function and not visible outside the function.

In order to implement this feature, we define a function as an anonymous function and invoke it immediately.
Suppose, for example, you have a module of javascript code that you want to use in a number of different javascript programs. Assume, like normal code, this code block defines a number
of variables to store intermediate results of the computation. the problem is that, since this module is used in many different javascript programs, We don't know whether the variables 
defined inside this module will conflict with the variables defined in another programs. The solution for this is that put the code in a function and then invoke that function. This way
variables would be local to that function only and will not spoil the global namespace.

example:
  function mymodule() {};
  mymodule();

this above code defines a single global variable called mymodule. if we don't want even this single global variable, then, we can create an anonymous function and invoke it immediately as below

(function(){}());

Example of this is in app.js

Closures
========
Like most programming languages, javascript uses lexical scoping.
What is lexical scoping?
Lexical scoping is a concept in programming language where an environment or context os determined by where the code is written, rather than where it is executed.
For example, imagine you have a few boxes (functions) and inside each box, you can put some variables. when you open a box, you can see what is inside the box. if you open a box within a box
you can also what is in the outer box.
so, lexical scoping means that a function can "see" and use variables from its own box and any outer box it's inside of, but it cannot access things from a box that is inside of it.

So, Lexical scoping is a rule that says "Where the code is written (it's location in the code) determines which variables the function can access"

In order to achieve the effect of lexical scoping, the internal state of the javascript function object must include not only the code of the function but also the reference to the current
scope chain.

In Javascript, the scope chain refers to a series of nested environments in which a particular piece of code will get executed. it's essentially a chain of variable lookups, where javascript
will search for the variables in the current scope, and if not found, it will lookup to outer scopes until it reaches the global scope.

1. Local Scope: when a variable is defined inside a function, that variable is part of the local scope
2. Outer Scope: if the variable is not found in the local scope, javascript will look for it in the outer scope.
3. Global Scope: if the variable is not found in any of the local scopes, Javascript will eventually searches the global scope.

the scope chain is the mechanism that javascript uses to resolve the variables. everytime a function is called, a new execution context is created, and within that context, there's a 
scope chain that consists of
1. the local scope (function's own variables)
2. the scope of the enclosing function (if the function is nested)
3. the global scope

javascript uses lexical scoping, meaning, the scope of the variables is determined by the location where the variables are defined but not where the function is called.
Execution Context: Every time a function is called, a new execution context is created which includes the scope chain of that function

This combination of the function object and the scope (a set of variable bindings) in which the function's variables are resolved is called a closure. 

Technically, all javascript functions are closures. they are objects, and they have a scope chain associated with them.

Most functions are invoked using the same scope chain that was in effect when the function is defined and it doesn't really matter that there is a closure involved.

Closures becomes interesting only when they are invoked in some different scope chain than the one that was in effect when they are defined. This happens mostly in the cases where a nested
function is returned as the value of the invocation expression. In order to understand closures well, we first need to understand the lexical scope rules for nested functions.

Ex:
  var scope = "global scope";
  function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f();
  }

  checkscope();

  Above code just returns "local scope" since the checkscope() defined a function f() and it was invoked internally itself. Since local scope available in that context, "local scope" string
  is returned. Now we make a small change to above program

  var scope = "global scope";
  function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f;
  }

  checkscope()();

  In this example, we are returning the inner function and this inner function then is invoked later. By the time, when we execute this line, the inner function already came out and should
  not be available any more. But in this case, the second line also gives "local scope" as output. this is because, the inner function is returned and this inner function execution context
  still holds reference to the outer function scope chain. Hence, the scope variable of outer function is still available in the outer function context and will be used.

  This concept is called closure.

  closures capture the local variable (and parameter)  bindings of the outer function within which they are defined.
  Each time a javascript function is invoked, a new object is created to hold the local variables for that invocation, and that object is added to the scope chain. When the function returns,
  that variable binding object is removed from the scope chain. If there were no nested functions, then, there will be no reference to the binding object and it gets garbage collected.
  If there were nested functions defined, then each of those functions will have a reference to the scope chain, and that scope chain refers to the variable binding object.

  If the nested function remained inside the outer function itself and is not returned, then, when the outer function is completed, along with the outer function, the inner functions also
  might got garbage collected. However, when a function defines an inner function and this inner function is stored somewhere out to the outer function, then, there will be an external
  reference to the inner function.

  Earlier we discussed about creating the unique integers where a property of a function can be used to store the state of the function. This is buggy in nature because anyone having access
  to this function can alter the value of that function property. Closures come to a rescue in these scenarios where closures capture the local variables of the single invocation function 
  and can use those variables as a private state.

  If we re-write the uniqueNumber generator as shown below
  
  var uniqueInteger = (function(){
    var counter = 0;
    return function () {
        return counter++;
    }
  }());

  If we observe this code, initially we think this line of code is assigning a function to a variable. But originally, we are creating an anonymous function and invoking that function on the
  spot. this function internally is holding a function property and there is another function defined inside this function and that function is returned which then will be invoked.
  This inner function inturn returns the incremented counter.

  From this code, we can understand that the counter variable is visible only within the inner function and is not visible anywhere outside the outer function. This provides the private 
  nature of the variable which cannot be accessed by any one else except the inner function. This is the advantage of using the closures.

  private variables like counter need not be exclusive to a single closure: it is perfectly possible for 2 or more nested functions to be defined within the same outer function and share the
  same scope chain.
  Ex:
    function counter() {
        var n=0;
        return {
            count: function () {return n++},
            reset: function() {n = 0;}
        };
    }

In this function, n is defined in the outer function counter(). The inner closure functions count and reset have access to n and both of them can access this variable and manipulate.

Trying to understand above code, the counter() function returns a counter object. counter object defines 2 methods count and reset that acts on private variable of the counter.
On each invocation of counter function, a new scope chain is created and each has it's own private counter. so manipulating private variable on one counter will not affect the private variable
of the other counter object.

It is worth to note that this closure technique can be combined with getters and setters. 
Example:
    function counter(n) { // Here n itself acts as a private variable
        get count() {return n++;},
        set count(val) {
            if (n > val) {
                throw TypeError();
            }
            n = val;
        }
    }

    var c = counter(1000); // Counter function object holds the value 1000 as its private state now
    c.count gives 1000 as value
    again call c.count. Now this returns 1001 since 1000 is already holded by counter function object and this value then will be incremented and returned
    c.count = 2000; This overrides the value of private variable inside counter function object with a value of 2000 since it is more than the current value of 1001
    c.count now gives 2000
    c.count = 2000; this throws an error because now this value is not greater than the inner state of the counter function object.

    refer app.js for execution details

The method explained above also gives us a chance to mention the initial value for the private variable.

It is important to note that the scope chain associated with a closure is "live". 
Another thing to remember while ariting a closure is "this" is a keyword but not a variable. Also every function will have a this value associated with the function object. this "this"
value is not available for the closures until unless this value is stored in some variable inside the outer function.

The same rule applies in case of arguments also. Each function invocation will have an arguments object associated with it. Since inner functions also will have their own arguments object
they can't access the arguments object of the outer function. Here also, if we save the arguments object of the outer function in some variable, then, this variable can be accessible by
the inner function there by accessing arguments object of the outer function.

Functions Properties, methods and Constructors
==============================================
Functions are values in javascript. the typeof operator returns the string "function" when applied to a function, but functions are really a specialized form of an object.
Since Functions are specialized object, they can have methods and properties.
There is even a Function Constructor that can be used to create a new function. 

The length property
-------------------
Within the body of a function, arguments.length specifies the number of arguments passed to the function. apart from this, the function object itself contains a length property which
will give the arity of the function which refers to the number of parameters declared in a function definition. This is usually the number of arguments a function expects.

The prototype property
----------------------
Every function has a prototype property that refers to the prototype object of the function. every function will have a different prototype object. When a function is used as a constructor,
the newly created object inherits properties from the prototype object.

The call and apply methods
--------------------------
Each and every function object will contain the call and apply methods inside it. these are used to indirectly invoke a function as a method on some other object.

the first argument of call or apply methods are objects on which the function needs to be called. this object becomes the invocation context of the function being invoked.
For example: To invoke a function f() on an object o, f.call(o), f.apply(o) can be used. here f is the function that needs to be invoked and o is the object on which this function needs
to be invoked.

in ECMAScript 5, the first argument to call or apply becomes the value of this even though that first argument is a primitive or null or undefined. in ECMAScript 3, if the first argument
is null or undefined, then that will be replaced with the global object.

in case of call, any argument after the first argument becomes the arguments for the function call
in case of apply, after first argument, the arguments to the function being invoked will be passed as the array of values.

If a function is defined to accept an aribitrary number of arguments, then, apply method allows you to invoke that function on the contents of array of arbitrary length.
note apply works both with pure arrays and array-like objects.

In particular, you can invoke a function with the same arguments as the current function by passing the arguments object directly to apply(). 
Example: refer app.js for an example

The method used above where altering an existing method dynamically with a new method is called "Monkey-Patching".
This concept is something similar to Aspects in Spring programming.

