  Before understanding the third way to create objects, we need to understand about prototypes.
  Each property of an object has three properties associated with them
     1. Writable : This decides whether a property can be writable or not
     2. Enumerable : This decides whether a property can be listed in for/in loop or not
     3. Configurable: This decides whether a property can be deleted or not, can be edited or not, can the other attributes of the property can be modified or not.
  
  Along with the above attributes for each of the property, there are 3 more attributes that are associated with the object itself. They are
     1. Prototype: This attribute is responsible for inheriting properties of some other object into the current object
     2. Class: This attribute defines the class of the current object
     3. Extensible: This attribute defines whether an object can be extensible or not. This acts something like final keyword in java.
 

Understanding prototypes
========================
A Prototype is an attribute associated with each of the object.

All Objects created with the same object literal will have the same prototype. This prototype can be referenced as Object.prototype.
Objects created with new keyword and the constructor function will use the prototype property of the constructor function. 
For example, 
    if the object is created using new Object(), then, prototype of this new object is same as prototype of Object i.e., Object.prototype
    if the object is created using new Array(), then, prototype of this new object is same as prototype of Array i.e., Array.prototype
    if the object is created using new Date(), then, prototype of this new object is same as prototype of Date i.e., Date.prototype
    if the object is created using new RegExp(), then, prototype of this new object is same as prototype of RegExp i.e., RegExp.prototype

Object.prototype is the only object that dont have any prototype and it doesn't inherit properties from any other object. All other objects will have prototypes and the root prototype
for all of them will be Object.prototype. This linked series of prototype objects is called prototype chaining.

ECMAScript 5 defines a method, Object.create(), that creates a new object, using its first argument as the prototype of the object created by Object.create(). This Object.create() function
takes an optional second argument also which defines the properties of the new object being created.

This Object.create() function is a static function and is not a method invoked on an individual objects. It use it, simply pass the desired prototype object
For example: var o1 = Object.create({x:1,y:2});

In the above example, object o1 will have it's prototype as {x:1,y:2}. This means, this object o1 will inherit the properties x and y that belongs to the prototype object.

If you specify null as a prototype of the object created using Object.create(), then, that object will not inherit any properties, even the general toString() method because this method
belongs to Object prototype.

The ability to create an object with an arbitrary prototype is a powerful technique.

Example of creating a new Object with an arbitrary prototype is described in app.js with method inherit().

The main use of inheriting objects in this manner have their own advantages. This is mainly used to avoid any unintended modifications of an object. For example, We have an object and we
want to pass this object to some library function. In order to avoid object getting damaged because of the library function, instead of sending the original object, we create a new object
with this new object having original object as prototype and then send this new clone object to library function. In this way, we can avoid getting the original object damaged 
by the library function.

In order to understand above concept thorougly, we need to understand how we can query an object and how properties can be set on the object.

Querying and Setting the Object properties
==========================================
To obtain the value of a property from an object,use . or [] operators. 
 1. if we are using . operator to access a property, left hand side should be an object and right hand side should be a simple identifier that names a property in the object
 2. If we are using [] operator to access a property, left hand side should be an object and right hand side can be an expression that when evaluated returns a simple String identifier
    that names a property in the object.

Because of the above rules, in . operator usage, we can't use property names that has spaces in it. But in case of [] operator, we can use any expression and this includes names that have
spaces in them as well.

In order to set a property, then put it like 
      <object>.<propertyName> = <value> 
         or 
      <object>[<propertyName>] = <value>

Objects as Associative Arrays
=============================
First of all what is an associative array mean? let's understand that.
Elements in an array will be accessed using numeric indices normally. When a element of an array is accessed using the names instead of numeric indices, then, we call that array as an
associative array. this means, the values of each element of an array are associated with a name and when we want to access, we access them using their names.

In Javscript, each object can act as an associative array where properties of an object can be accessed using array notation and name of the property. For example,
Consider below object
   var obj = {
      x:1,
      y:2
   };

We can access the property x from obj as obj["x"]. Here we are using array notation to access x from obj. This means, we are using the name of the property. This is why we call each object
in javascript acts as an associative array.

In order to understand the dynamic nature of objects in Javascript, we need to first understand what is strongly typed language mean and what is loosely typed language mean

Strongly Typed Vs Loosely Typed
-------------------------------
The terms stronly typed and loosely typed refer to how a programming language handles the variables and their types. They describe the strictness or flexibility with which the language
checks types at compile time or run time.

In a strongly typed languages like java, types are enforced. This means, once a variable is defined as a certain type, then, this variable can be assigned with values of the same type only.
Assigning these variables with values of some other type will not be allowed and a compile time error will be raised by the compiler. If we want to assign a value other than the variable type,
then only approach is to perform casting to convert the value.

In a loosely typed language like javascript, types are not enforced. this means, even after defining a variable with certain type, a value of any other type can be assigned to this variable
and compiler will take care of automatic conversion of that value to the required type. the check for the types will be done only during the run time.

In Strongly typed languages, errors with variable types can be caught early on during the compile time itself but in loosely typed languages this is not the case and the errors can be caught
only during the run time.


Summary of Differences between strongly typed and loosely typed languages:

Feature	            Strongly Typed Language	                  Loosely Typed Language
---------------------------------------------------------------------------------------------------
Type Enforcement	  Strict enforcement of types	            Types are flexible, checked at runtime
Type Checking	      Done at compile-time (or runtime)	        Done at runtime
Reassignment	      Cannot reassign different types easily	Variables can be reassigned to different types
Error Handling	      Type errors are caught early	            Type errors may not appear until runtime
Examples	          Java, C++, Swift	                        JavaScript, Python, Ruby
------------------------------------------------------------------------------------------------------

Objects as Associative Arrays continued...

Now, we know what is strongly typed and loosely typed languages mean. Javascript is a loosely typed language.
In strongly typed languages, once an object is defined and properties and methods are defined inside those objects and their types are already decided, then, it cannot be changed dynamically.
But, in case of loosely typed languages, even once a object is defined and properties and methods with certain types are already defined, that object can still be modified where
we can add new properties, delete existing properties, change the type of properties and so on dynamically.

So, using the associative array like nature of an object, properties in an object can be manipulated dynamically where a new property can be added to object on the fly.

Inheritance
============
Java script objects will have a set of "Own" Properties. Along with this, they inherit some properties from their prototype objects as well. 

Suppose you query a property x of an object o. if o does not have it's own property with the name x, then, the prototype of object o will be queried for the property x. If prototype of o does
not have its own property by name x but has a prototype itself, then that prototype will be queried. In this way, query for the property will be performed until it reaches a point where
the prototype itself is null. In this way, there will be a chain or linked list of prototype objects will be present for each of the object in javascript.


var o = {} // o inherits object methods from Object.prototype
o.x = 1; // o now has a own property by name x
var p = inherit(o) //p inherits from o and Object.prototype
p.y = 2; // p now has a own property by name you
var q = inherit(p); // q inherits from o, p and Object.prototype
q.z = 3; // q now has a own property by name z

Now suppose we assign a value to the property x of the object o. If o has already own property x, then, value of this x will be changed. if x is not present in o, then, a new property by name x
will be created in o and then value will be assigned to that property.
if by any chance, o inherited x from some other object, then, that inherited property will be hidden with this o's own property.

property assignment examines the prototype chain of an object. if object inherits a read only property and if we try to assign to that property, it will not be allowed. If assignment is
allowed, then, property will be set or created in original object and the prototype object will never be touched.

the fact that inheritence occurs only when querying properties but not setting properties allows us to selectively override inherited properties. We already know that properties in inherited
prototype will never be touched or changed but there is one exception to this rule. If the inherited property is a setter method and when we try to assign a value to the property whose value
is a setter method, in that case, the setter method will be called instead of setting the value. Even in this case of calling a setter method, if setter method modifies any properties, then,
it will be able to do that on the original object only and not on the parent object. In this scenario also, parent object will be left untouched.


Property Access errors
------------------------
property access expressions will not always returns or sets a property. let's see what happens in these scenarios while trying to query or set a property

normally, in javascript, it is not an error to query a property that doesn't exist in an object. if a property is not present as an own property or inherited property in an object, then,
undefined will be returned. However, it is an error to try to query a property on a object which doesn't exist. the null and undefined won't have any properties and is an error to query
for properties on null or undefined. in order to avoid this type of errors, before accessing a property on an object, we first need to check whether the object exists or not.

This applies even in case of setting a property on an object that doesn't exist where an error (TypeError) will be thrown. There are other scenarios also where a property might be defined as
read only and trying to assign a value to that property will throw a TypeError. There might be a property that is non-configurable or non-writable and is read only and trying to assign a value
to this property also throws a TypeError.

The rules that specify when a property assignment succeeds and when it fails are intuitive but difficult to express concisely. an attempt to set a property p of an object o fails in these
circumstances

1. o has a own property p that is read-only.
2. o has an inherited property p that is read-only
3. o doesn't have an own property p; o doen't inherit a property p with a setter method, and o's extensible attribute is false. 

Deleting Properties
-------------------
Delete operator deletes a property from an object and its single operand should be a property access expression. This operator doesn't operate on the value of the property but on the 
property itself.
it is worth to remember that delete property only deletes own properties but not the inherited properties. the delete expression evaluates to true only when the property is deleted or the property
is not affected at all.
delete does not remove properties whose configurable attribute is false. certain properties of built-in objects are not configurable, as are the properties of the global object created by
variable declaration and function declaration.

Testing Properties
------------------
If we want to check whether a property is present in an object or not, below methods are available
1. check with in operator
   ex: var o = {x:1}, "x" in o
2. Using ownProperty() method on the object. This method is inherited from the Object. This method returns false for inherited properties.
   ex: var o = {x:1}, o.hasOwnProperty("x")
3. propertyIsEnumerable() method on the object. This method further refines hasOwnProperty() where it checks whether the property is own property and also it's enumerable attribute is true
   ex: var o = {x:1}, o.isPropertyEnumerable("x")

Enumerating Properties
----------------------
Instead of querying an object for the existence of a property, sometimes we might need to enumerate all the properties present in an object.
For this purpose, we normally use for/in loop.
for/in loop enumerates only those properties of an object whose enumerable attribute is set to true. For this reason, since some properties of built-in objects are non-enumerable, they will
not be enumerated with for/in loop.

Some utility libraries add new methods to Object.prototype so that they will be available for all the objects down the hierarchy. Prior to ECMAScript 5, 
there is no way to make these utility methods non-enumerable to avoid being listed in for/in loop. But with ECMAScript 5, properties can be marked as non-enumerable by setting 
their enumerable property to false and hence avoid enumerated by for/in loop.

app.js file contains some utility methods that can be used to manipulate properties of an object. Please have a look

In addition to for/in loop, ECMAScript 5 defines 2 more methods to enumerate properties. They are
1. Object.keys() : This returns an array of enumerable properties 
2. Object.getOwnPropertyNames(): This gives all own properties including non-enumerable properties as well.

Property Getters and Setters
----------------------------
We already know that a property of an object is a name, a value and a set of attributes. In ECMAScript 5, the value may be replaced by one or more methods, known as getter and setter.
properties defined with getters and setters are sometimes referred to as accessor properties to distinguish them from data properties that have a simple value.

When a program queries the value of an accessor property, Javascript invokes the getter method of that property access expression. In the same way, when a program sets a value to the accessor
property, Javascript calls the setter method of that property passing the value of the assignment. this method is responsible for setting a value and the return value of this method is ignored.

Accessor properties do not have a writable attribute as normal data properties have. if a property has both getter and setter methods, then it is read/write. if any one only is present, then,
if getter, it is read-only, if setter, it is write-only.

The easiest way to define accessor properties is with an extension to the object literal syntax

ex:
  var o = {
    // An ordinary data property
    data_prop: value,

    //An Accessor property defined as a pair of functions
    get accessor_prop {/** Function body goes here*/},
    set accessor_prop(value) {/** Function Body goes here*/}
  };

  If we observe here, the setter and getter properties are not separated with : but methods are separated with ,. When accessing data properties from inside 
  this getters and setters, we need to use this keyword. Since setters and getters are invoked as methods on the object, this object is referenced by this 
  keyword and this is the reason, other data properties of the object are made available to these methods.

  also, these accessor methods can be inherited by the sub classes. the other use of using the getters and setters is that 
  these methods can be used to perform sanity checking on when we try to set the values for the data properties and when we try to read the same.

  The example of using getters and setters to perform sanity checking is shown in app.js with the definition of a variable serial Number. 
  In this variable, we are defining a function with getters and setters so that sanity check will be performed before returning the serial number. Please refer the same for understanding.

  Till now we discussed about creating getters and setters as part of new Object Creation. Next we will see how we can add these to an existing object as well.

  Property Attributes
  -------------------
  In addition to name and value, each property is associated with 3 attributes. Writable, enumerable and configurable. In ECMAScript 3, these properties are by default writable, enumarable,
  and configurable for each property and there is no way to control them. But from ECMAScript 5, we can control these properties.

  These attributes are particularly important for library authors because
  1. it allows them to add methods to prototype objects and make them non-enumerable like built-in methods
  2. it allows them to lock down the objects defining properties that cannot be changed or deleted.

  To clearly understand these things, lets consider the data property also as one of the attributes of a property. In this case, each property can have a name and 4 attributes listed below
  1. data/value
  2. Writable
  3. Enumerable
  4. Configurable

In case of accessor properties, there will be no value and writable properties. Instead we have get, set. So, in this case also, for accessor properties there are 4 attributes
1. set
2. get
3. Enumerable
4. Configurable

ECMAScript 5 methods for querying and setting the attributes of a property use an object called Property Descriptor to represent the set of 4 attributes.
A Property Descriptor object has properties with the same names as the attributes of a property. Thus it will have properties with names value, writable, enumerable and configurable.
similarly a property descriptor object for a accessor property will have properties with names get, set, enumerable and configurable.

the value property holds value of an expression, writable, enumerable and configurable are boolean values, set and get methods are functions.

to obtain the property descriptor for a named property of a specified object, call Object.getOwnPropertyDescriptor() with object as the first parameter and the property as the second parameter.

ex: Object.getOwnPropertyDescriptor({x:1}, "x");

in this example, we are getting the property descriptor for the property x present in object {x:1}

To set a attribute for a property or to create a new property with the specified attributes, then, call Object.defineProperty() method, passing the object to be modified, name of the property to which attributes needs to be set and the property descriptor.

Example: refer app.js
After adding the property x and printing the properties of the object, below is the output
 Property newly added: x
Properties of object o: 

This indicates that property x is added to the object but when we print the properties of the object using Object.keys(), we dont see this property. this is because, property x is not
enumerable.

Now, we switched the writable property to false and then try to set the value of x in which case, it is not changed and fails silently.
Since the property is still configurable, we can change the value of the property using the property descriptor


